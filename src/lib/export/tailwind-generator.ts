/**
 * Tailwind Config Generator
 * Transforms design system tokens into tailwind.config.js
 */

import type { DesignSystem } from '@/types/design-system'

/**
 * Generate complete Tailwind config from design tokens
 */
export function generateTailwindConfig(designSystem: DesignSystem): string {
  const config = {
    content: ['./src/**/*.{js,jsx,ts,tsx}', './index.html'],
    theme: {
      extend: {
        colors: generateColorsConfig(designSystem),
        fontFamily: generateFontFamilyConfig(designSystem),
        fontSize: generateFontSizeConfig(designSystem),
        fontWeight: generateFontWeightConfig(designSystem),
        lineHeight: generateLineHeightConfig(designSystem),
        letterSpacing: generateLetterSpacingConfig(designSystem),
        spacing: generateSpacingConfig(designSystem),
        borderRadius: generateBorderRadiusConfig(designSystem),
        boxShadow: generateBoxShadowConfig(designSystem),
        transitionDuration: generateDurationConfig(designSystem),
        transitionTimingFunction: generateEasingConfig(designSystem),
        zIndex: generateZIndexConfig(designSystem),
      },
    },
    plugins: [],
  }

  // Format as JavaScript module with JSDoc
  const header = `/**
 * ${designSystem.name || 'Design System'} - Tailwind Configuration
 * Generated by Design System Builder
 * Version: ${designSystem.version || '1.0.0'}
 * Generated: ${new Date().toISOString()}
 * 
 * @type {import('tailwindcss').Config}
 */
export default `

  return header + formatConfig(config)
}

/**
 * Generate colors configuration
 */
function generateColorsConfig(designSystem: DesignSystem) {
  const colors: Record<string, string | Record<string, string>> = {}

  // Brand colors with full scales
  if (designSystem.colors.primary) {
    colors.primary = { ...designSystem.colors.primary }
  }

  if (designSystem.colors.secondary) {
    colors.secondary = { ...designSystem.colors.secondary }
  }

  if (designSystem.colors.accent) {
    colors.accent = { ...designSystem.colors.accent }
  }

  // Gray scale
  if (designSystem.colors.gray) {
    colors.gray = { ...designSystem.colors.gray }
  }

  // Semantic colors with full scales
  if (designSystem.colors.success) {
    const successBase =
      typeof designSystem.colors.success === 'object' &&
      '500' in designSystem.colors.success
        ? designSystem.colors.success[500]
        : designSystem.colors.success
    colors.success = {
      DEFAULT: String(successBase),
      ...(typeof designSystem.colors.success === 'object'
        ? designSystem.colors.success
        : {}),
    }
  }

  if (designSystem.colors.warning) {
    const warningBase =
      typeof designSystem.colors.warning === 'object' &&
      '500' in designSystem.colors.warning
        ? designSystem.colors.warning[500]
        : designSystem.colors.warning
    colors.warning = {
      DEFAULT: String(warningBase),
      ...(typeof designSystem.colors.warning === 'object'
        ? designSystem.colors.warning
        : {}),
    }
  }

  if (designSystem.colors.error) {
    const errorBase =
      typeof designSystem.colors.error === 'object' &&
      '500' in designSystem.colors.error
        ? designSystem.colors.error[500]
        : designSystem.colors.error
    colors.error = {
      DEFAULT: String(errorBase),
      ...(typeof designSystem.colors.error === 'object'
        ? designSystem.colors.error
        : {}),
    }
  }

  if (designSystem.colors.info) {
    const infoBase =
      typeof designSystem.colors.info === 'object' &&
      '500' in designSystem.colors.info
        ? designSystem.colors.info[500]
        : designSystem.colors.info
    colors.info = {
      DEFAULT: String(infoBase),
      ...(typeof designSystem.colors.info === 'object'
        ? designSystem.colors.info
        : {}),
    }
  }

  // Surface colors
  colors.background = designSystem.colors.background
  colors.foreground = designSystem.colors.foreground

  colors.card = {
    DEFAULT: designSystem.colors.card,
    foreground: designSystem.colors.cardForeground,
  }

  colors.popover = {
    DEFAULT: designSystem.colors.popover,
    foreground: designSystem.colors.popoverForeground,
  }

  colors.muted = {
    DEFAULT: designSystem.colors.muted,
    foreground: designSystem.colors.mutedForeground,
  }

  // Border & focus colors
  colors.border = designSystem.colors.border
  colors.input = designSystem.colors.input
  colors.ring = designSystem.colors.ring

  return colors
}

/**
 * Generate font family configuration
 */
function generateFontFamilyConfig(designSystem: DesignSystem) {
  return {
    sans: designSystem.typography.fontFamily.sans,
    serif: designSystem.typography.fontFamily.serif,
    mono: designSystem.typography.fontFamily.mono,
  }
}

/**
 * Generate font size configuration with line heights
 */
function generateFontSizeConfig(designSystem: DesignSystem) {
  const fontSize: Record<string, [string, { lineHeight: string }]> = {}

  const sizeMap: Record<string, string> = {
    xs: '1rem',
    sm: '1.25rem',
    base: '1.5rem',
    lg: '1.75rem',
    xl: '1.75rem',
    '2xl': '2rem',
    '3xl': '2.25rem',
    '4xl': '2.5rem',
    '5xl': '1',
    '6xl': '1',
    '7xl': '1',
    '8xl': '1',
    '9xl': '1',
  }

  Object.entries(designSystem.typography.fontSize).forEach(([size, value]) => {
    fontSize[size] = [String(value), { lineHeight: sizeMap[size] || '1.5rem' }]
  })

  return fontSize
}

/**
 * Generate font weight configuration
 */
function generateFontWeightConfig(designSystem: DesignSystem) {
  const fontWeight: Record<string, string> = {}

  Object.entries(designSystem.typography.fontWeight).forEach(
    ([weight, value]) => {
      fontWeight[weight] = String(value)
    },
  )

  return fontWeight
}

/**
 * Generate line height configuration
 */
function generateLineHeightConfig(designSystem: DesignSystem) {
  const lineHeight: Record<string, string> = {}

  Object.entries(designSystem.typography.lineHeight).forEach(([key, value]) => {
    lineHeight[key] = String(value)
  })

  return lineHeight
}

/**
 * Generate letter spacing configuration
 */
function generateLetterSpacingConfig(designSystem: DesignSystem) {
  const letterSpacing: Record<string, string> = {}

  Object.entries(designSystem.typography.letterSpacing).forEach(
    ([key, value]) => {
      letterSpacing[key] = String(value)
    },
  )

  return letterSpacing
}

/**
 * Generate spacing configuration (only custom values)
 */
function generateSpacingConfig(designSystem: DesignSystem) {
  // Tailwind already has good defaults for spacing
  // Only include custom values that differ from defaults
  const spacing: Record<string, string> = {}

  const tailwindDefaults: Record<string, string> = {
    '0': '0',
    px: '1px',
    '0.5': '0.125rem',
    '1': '0.25rem',
    '1.5': '0.375rem',
    '2': '0.5rem',
    '2.5': '0.625rem',
    '3': '0.75rem',
    '3.5': '0.875rem',
    '4': '1rem',
    '5': '1.25rem',
    '6': '1.5rem',
    '7': '1.75rem',
    '8': '2rem',
    '9': '2.25rem',
    '10': '2.5rem',
    '11': '2.75rem',
    '12': '3rem',
    '14': '3.5rem',
    '16': '4rem',
    '20': '5rem',
    '24': '6rem',
    '28': '7rem',
    '32': '8rem',
    '36': '9rem',
    '40': '10rem',
    '44': '11rem',
    '48': '12rem',
    '52': '13rem',
    '56': '14rem',
    '60': '15rem',
    '64': '16rem',
    '72': '18rem',
    '80': '20rem',
    '96': '24rem',
  }

  // Check if any custom spacing differs from defaults
  Object.entries(designSystem.spacing).forEach(([key, value]) => {
    const defaultValue = tailwindDefaults[key]
    if (value !== defaultValue) {
      spacing[key] = String(value)
    }
  })

  // Return empty object if no custom spacing
  return Object.keys(spacing).length > 0 ? spacing : undefined
}

/**
 * Generate border radius configuration
 */
function generateBorderRadiusConfig(designSystem: DesignSystem) {
  const borderRadius: Record<string, string> = {}

  Object.entries(designSystem.borderRadius).forEach(([key, value]) => {
    if (key === 'base') {
      borderRadius.DEFAULT = String(value)
    } else {
      borderRadius[key] = String(value)
    }
  })

  return borderRadius
}

/**
 * Generate box shadow configuration
 */
function generateBoxShadowConfig(designSystem: DesignSystem) {
  const boxShadow: Record<string, string> = {}

  Object.entries(designSystem.boxShadow).forEach(([key, value]) => {
    if (key === 'base') {
      boxShadow.DEFAULT = String(value)
    } else {
      boxShadow[key] = String(value)
    }
  })

  return boxShadow
}

/**
 * Generate transition duration configuration
 */
function generateDurationConfig(designSystem: DesignSystem) {
  return {
    fast: designSystem.animation.duration.fast,
    DEFAULT: designSystem.animation.duration.normal,
    slow: designSystem.animation.duration.slow,
  }
}

/**
 * Generate easing function configuration
 */
function generateEasingConfig(designSystem: DesignSystem) {
  return {
    DEFAULT: designSystem.animation.easing.inOut,
    linear: designSystem.animation.easing.linear,
    in: designSystem.animation.easing.in,
    out: designSystem.animation.easing.out,
    'in-out': designSystem.animation.easing.inOut,
  }
}

/**
 * Generate z-index configuration
 */
function generateZIndexConfig(designSystem: DesignSystem) {
  const zIndex: Record<string, string | number> = {}

  Object.entries(designSystem.zIndex).forEach(([key, value]) => {
    zIndex[key] = typeof value === 'number' ? value : String(value)
  })

  return zIndex
}

/**
 * Format config object as formatted JavaScript code
 */
function formatConfig(config: unknown, indent = 0): string {
  const spaces = '  '.repeat(indent)

  if (config === null || config === undefined) {
    return 'undefined'
  }

  if (typeof config === 'string') {
    return `'${config.replace(/'/g, "\\'")}'`
  }

  if (typeof config === 'number' || typeof config === 'boolean') {
    return String(config)
  }

  if (Array.isArray(config)) {
    if (config.length === 0) return '[]'

    const items = config.map((item) => {
      if (typeof item === 'string') {
        return `'${item.replace(/'/g, "\\'")}'`
      }
      return formatConfig(item, indent + 1)
    })

    return `[\n${spaces}  ${items.join(`,\n${spaces}  `)},\n${spaces}]`
  }

  if (typeof config === 'object') {
    const entries = Object.entries(config).filter(
      ([, value]) => value !== undefined,
    )

    if (entries.length === 0) return '{}'

    const lines = entries.map(([key, value]) => {
      const formattedKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)
        ? key
        : `'${key}'`
      const formattedValue = formatConfig(value, indent + 1)
      return `${spaces}  ${formattedKey}: ${formattedValue}`
    })

    return `{\n${lines.join(',\n')},\n${spaces}}`
  }

  return String(config)
}

/**
 * Calculate file size in KB
 */
export function getTailwindConfigFileSize(config: string): number {
  return new Blob([config]).size / 1024
}

/**
 * Validate Tailwind config for common issues
 */
export function validateTailwindConfig(designSystem: DesignSystem): {
  valid: boolean
  warnings: string[]
} {
  const warnings: string[] = []

  // Check for missing essential colors
  if (!designSystem.colors.primary) {
    warnings.push('Primary color is missing')
  }

  if (!designSystem.colors.background) {
    warnings.push('Background color is missing')
  }

  // Check for incomplete color scales
  if (designSystem.colors.primary) {
    const primaryShades = Object.keys(designSystem.colors.primary)
    if (primaryShades.length < 11) {
      warnings.push(
        `Primary color scale is incomplete (${primaryShades.length}/11 shades)`,
      )
    }
  }

  // Check font families
  if (designSystem.typography.fontFamily.sans.length === 0) {
    warnings.push('Sans-serif font family is empty')
  }

  // Check for very large configs
  const config = generateTailwindConfig(designSystem)
  const size = getTailwindConfigFileSize(config)
  if (size > 100) {
    warnings.push(
      `Config file is large (${size.toFixed(2)}KB). Consider simplifying.`,
    )
  }

  return {
    valid: warnings.length === 0,
    warnings,
  }
}
